
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Blog kỹ thuật máy tính</title>
	<meta name="author" content="kỹ thuật máy tính">

	
	<meta name="description" content="May 6th, 2015 KTMT,, Kipalog, blogging,, platform,, programming,, technical, writing, Comments Kipalog: Câu Chuyện về Viết và Chia Sẻ Lập trình bằng &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Blog kỹ thuật máy tính" type="application/atom+xml">
	
	<link rel="canonical" href="http://git@github.com.github.com/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
  </script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="notif">
		<p>
			Cảm ơn bạn đã đọc và ủng hộ blog KTMT ʘ‿ʘ
			Từ bây giờ chúng tôi sẽ là
			<a target="_blank" href="/blog/2015/05/06/kipalog-cau-chuyen-ve-viet-va-chia-se/">
				kipalog.com
			</a>
			!
		</p>
	</div>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	<script src="/javascripts/md5.js"></script>
	<img src='/images/logo.jpg' alt='Profile Picture' style='width: 160px;' />
</div>
<h1><a href="/">Blog kỹ thuật máy tính</a></h1>
<p class="subtitle">kỹ thuật máy tính</p>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav class="hint">
	<p>
	  Cập nhật thông tin bài viết qua Facebook page hay link RSS dưới đây
	</p>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="facebook" href="http://www.facebook.com/pages/ktmtgithubio/486208978117754" title="Facebook">Facebook</a>
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>
			</div>
		</div>
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-05-06T16:43:00+09:00" data-updated="true" itemprop="datePublished">May 6<span>th</span>, 2015</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/ktmt/'>KTMT,</a>, <a class='category' href='/blog/categories/kipalog/'>Kipalog</a>, <a class='category' href='/blog/categories/blogging/'>blogging,</a>, <a class='category' href='/blog/categories/platform/'>platform,</a>, <a class='category' href='/blog/categories/programming/'>programming,</a>, <a class='category' href='/blog/categories/technical/'>technical</a>, <a class='category' href='/blog/categories/writing/'>writing,</a>


</div>
		
			<span class="comments"><a href="/blog/2015/05/06/kipalog-cau-chuyen-ve-viet-va-chia-se/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/05/06/kipalog-cau-chuyen-ve-viet-va-chia-se/" itemprop="url">Kipalog: Câu Chuyện về Viết và Chia Sẻ</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1 id="lập-trình-bằng-google">Lập trình bằng Google</h1>
<p>Trước khi viết KTMT, công việc hàng ngày của chúng tôi đã từng theo một vòng lặp như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span>proc.sh </span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre>
</td>
<td class="code">
<pre><code class='sh'><span class='line'><span class="k">while</span> <span class="o">(</span>còn vấn đề kỹ thuật cần giải quyết<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">while</span> <span class="o">(</span>chưa biết cách giải quyết<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    Google   <span class="c"># Google trả lời bằng rất nhiều lời giải...</span>
</span><span class='line'>    foreach<span class="o">(</span>kết quả<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      Thử từng kết quả
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Chúng tôi nhận ra có rất nhiều vấn đề ở vòng lặp này: vấn đề tìm kiếm cũng như lời giải hoàn toàn vụn vặt và thiếu tính khái quát, cùng một vấn đề hoặc vấn đề tương tự nhau nhưng nhiều khi phải google rất nhiều, nhiều khi giải quyết được vấn đề nhưng đấy lại không phải là cách giải quyết tốt nhất, cách giải quyết tốt nhất nhiều khi lại đến từ bạn bè xung quanh mình.</p>
<p>Chúng tôi nhận thấy nếu như không tổng hợp lại những điều mình đã tìm hiểu thì sẽ không có cách nào nhớ được cách giải quyết. Cách đơn giản nhất mà chúng tôi đã nhận thấy là <strong>viết</strong> và <strong>chia sẻ</strong> cho bạn bè. <strong>Viết</strong> giúp tổng hợp các cách giải quyết vấn đề, giúp lưu lại cách giải quyết đó cho những lần sau. Viết cũng chính là <strong>giải thích</strong> lại vấn đề cho chính bản thân sau này. <strong>Chia sẻ</strong> giúp nhận được góp ý từ những người giỏi hơn mình. Do vậy chúng tôi đã bắt đầu blog KTMT. Giống như đã viết ở <a href="http://ktmt.github.io/blog/2015/03/08/ktmt-blog-nguon-mo/">KTMT blog nguồn mở</a>, chúng tôi nhận thấy chúng tôi dần dần thoát khỏi vòng lặp nói trên.</p>
<figure>
<img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/blob_6ynsrhkggx" />
</figure>
<h1 id="viết-có-chắc-chắn-là-cách-giải-quyết-vấn-đề">“Viết” có chắc chắn là cách giải quyết vấn đề?</h1>
<ul>
<li><strong>Albert Einstein</strong> đã từng nói:</li>
</ul>
<figure>
<img src="https://s3-ap-southeast-1.amazonaws.com/kipalog.com/blob_t1aodwath4" />
</figure>
<p>Để hiểu rõ một điều gì đó, hãy thử giải thích điều đó một cách <strong>đơn giản</strong> nhất.</p>
<ul>
<li><strong>Leslie B. Lamport</strong> đã từng nói:</li>
</ul>
<blockquote>
<p>If you’re thinking without writing, you only think you’re thinking.</p>
</blockquote>
<p>Khi chúng ta không viết ra, chúng ta chỉ <em>tưởng</em> là chúng ta đã biết thôi. Thực sự là chúng ta là <em>chưa biết</em> gì cả.</p>
<p><em>Hãy giải thích một cách đơn giản</em> và <em>hãy viết ra</em> là thông điệp của 2 vĩ nhân trên. Do vậy chúng tôi tin tưởng viết chính là cách giải quyết cho vấn đề của chúng tôi.</p>
<h1 id="viết-liệu-có-khó-khăn">Viết liệu có khó khăn?</h1>
<p>Bắt đầu viết không hề đơn giản. Chúng tôi đã từng <a href="http://ktmt.github.io/blog/2014/09/08/tong-ket-ban-dieu-tra-ve-thoi-quen-programmer-cua-blog-ktmt/">thử khảo sát</a> và nhận ra viết lách thật sự không hề dễ. Các bạn trả lời cho điều tra trên gặp những vấn đề sau đây:</p>
<h4 id="suy-nghĩ-chỉ-chuyên-gia-mới-viết-được-bài-viết-kĩ-thuật">Suy nghĩ: “Chỉ chuyên gia mới viết được bài viết kĩ thuật?”</h4>
<blockquote>
<p>Tôi không phải là một chuyên gia về một vấn đề gì cả, vậy nên chả biết viết về cái gì cả!!</p>
</blockquote>
<p>Đây có lẽ là một lý do thiếu thuyết phục nhất. Bạn không cần phải là chuyên gia mới viết được blog. Trong 85 bài viết của KTMT blog, có những chủ đề mà chúng tôi hoàn toàn chưa hiểu rõ cho đến khi bắt tay vào tìm hiểu và viết lại. Và chính nhờ việc nghiên cứu rất nhiều để viết đã giúp chúng tôi hiểu ra nhiều điều.</p>
<h4 id="viết-sai-làm-tôi-trông-như-một-đứa-ngớ-ngẩn">Viết sai làm tôi trông như một đứa ngớ ngẩn?</h4>
<blockquote>
<p>Nếu tôi viết một thứ gì đó không đúng, hay viết sai, tôi sẽ bị nhìn như một thằng đần trên internet</p>
</blockquote>
<p>Đây có lẽ là một lý do làm nhiều bạn “sợ” viết nhất. Chúng tôi cũng như bạn, chúng tôi cũng dễ mắc phải các sai lầm. Không phải 100% kiến thức chúng tôi viết ra ngay lần đầu tiên là chính xác. Và chính các bạn, những người đọc là những người giúp chúng tôi nhận ra điều đó, trách nhiệm của chúng tôi là sửa lại cho đúng. Vậy ai là người có lợi ở đây: người viết ra, hay người không viết ra? Chắc các bạn có thể tự trả lời được câu hỏi này.</p>
<blockquote>
<p>Điều quan trọng nhất tự việc nhầm lẫn (make mistake) là việc thu dọn những nhầm lẫn đó, và học những điều mới từ nó.</p>
</blockquote>
<h4 id="viết-tốt-quá-khó">Viết tốt quá khó!</h4>
<blockquote>
<p>Tôi có thể code tốt, nhưng viết thì chịu, viết câu cú đúng ngữ pháp, có nội dung hợp lý với tôi như một cực hình.</p>
</blockquote>
<p>Điều này chúng tôi hoàn toàn đông ý với bạn. Viết tốt là một trong những điều khó nhất mà tôi từng biết. Viết để cho mình hiểu đã khó, cho người khác, đặc biệt là cho những người không cùng kĩ năng với bạn hiểu được còn khó hơn. Tuy nhiên trong công việc hàng ngày, 50% việc bạn phải làm là <strong>giao tiếp</strong>, là <em>nói cái mình hiểu cho người khác hiểu</em>. Việc tập luyện kĩ năng <em>viết</em> cho <em>người khác hiểu</em> chính là giúp tăng kĩ năng giao tiếp của bạn lên. Hãy kiên trì và sẽ đến một lúc các bạn nhận ra rằng việc <strong>viết tốt</strong> giúp bạn nhiều đến thế nào.</p>
<p>Hy vọng bài viết đến đây đã truyền tải được phần nào những gì chúng tôi đang suy nghĩ về việc chia sẻ các vấn đề kĩ thuật bằng cách viết ra. Chính vì tầm quan trọng của việc chia sẻ các kiến thức kĩ thuật, và muốn phủ rộng hơn văn hoá viết ra và chia sẻ với cộng đồng kĩ thuật tại Việt Nam nói chung, chúng tôi đã quyết định làm một điều lớn hơn là chỉ <a href="http://ktmt.github.io/blog/2015/03/08/ktmt-blog-nguon-mo/">open blog</a>.</p>
<h1 id="ngôi-nhà-mới-kipalog.com">Ngôi nhà mới <a href="http://kipalog.com">kipalog.com</a></h1>
<p>Chúng tôi đã quyết định xây dựng một nền tảng, mà ở đó ai cũng có thể viết để chia sẻ kiến thức của mình một cách dễ dàng, có thể tìm kiếm và học hỏi kiến thức có chất lượng từ những người cùng làm kĩ thuật chuyện nghiệp khác. Bạn hãy tưởng tượng đó là một <em>kho</em> kiến thức chất lượng cao, một môi trường cởi mở và tôn trọng lẫn nhau của những người có cùng niềm đam mê về kĩ thuật.</p>
<p>Nền tảng được đặt tên là <strong>Kipalog</strong> và đặt tại trang web: <a href="http://kipalog.com" class="uri">http://kipalog.com</a></p>
<p>Kipalog là cách gọi tắt của “keep a log”, cũng chính là khái niệm chủ đạo của nền tảng này, coi trọng việc “log” hay là giữ lại các kiến thức của bạn bằng cách “viết ra”.</p>
<p>Vậy bạn có thể làm gì với Kipalog:</p>
<ul>
<li>Bạn có thể <strong>viết</strong> để chia sẻ kiến thức kĩ thuật của bạn với người khác. Chúng tôi cung cấp cho bạn trình soạn thảo markdown với khả năng hiển thị trực quan theo 2 cột, kéo thả / cắt dán ảnh trực tiếp và nhiều tiện ích khác, giúp bạn cảm thấy thoải mái khi viết một tài liệu kĩ thuật.</li>
<li>Bạn có thể đọc, học hỏi và <strong>kipalog</strong> kiến thức của người khác. Việc <strong>kipalog</strong> giúp bạn giữ lại những kiến thức cần thiết cho bản thân để có thể tìm lại dễ dàng về sau.</li>
<li>Bạn có thể trao đổi, cung cấp phản hồi cho các bạn khác. Nếu bạn có cách giải quyết tốt hơn, hãy đóng góp thông qua bình luận. Bản thân bình luận cũng có thể viết bằng markdown.</li>
<li>Các công ty và tổ chức chia sẻ công nghệ cũng như kinh nghiệm của bản thân công ty mình, đồng thời thu lợi được công nghệ và kinh nghiệm từ các công ty và tổ chức khác.</li>
</ul>
<p>Tại sao bạn nên bắt tay vào đăng ký và viết bài trên Kipalog:</p>
<ul>
<li>Tại Kipalog, chúng tôi đảm bảo việc chia sẻ và phản hồi đều dựa trên tinh thần tôn trọng lẫn nhau.</li>
<li>Năng lực của bạn sẽ được thể hiện qua những gì bạn viết. Những bài viết tốt chứ không phải là số năm kinh nghiệm thể hiện bạn là một kĩ sư chuyên nghiệp và có trình độ cao.</li>
<li>Bạn sẽ có cơ hội kết bạn và giao lưu với những người cùng đam mê kĩ thuật khác (trong đó có những người viết của chính blog KTMT).</li>
</ul>
<h1 id="vậy-ktmt-sẽ-ra-sao">Vậy KTMT sẽ ra sao?</h1>
<p>Chúng tôi sẽ chuyển blog KTMT thành một <strong>tổ chức</strong> trên Kipalog.</p>
<blockquote>
<p><a href="http://kipalog.com/organizations/KTMT" class="uri">http://kipalog.com/organizations/KTMT</a></p>
</blockquote>
<p>Blog KTMT sẽ vẫn được giữ ở trạng thái hoạt động, nhưng sẽ không cập nhật các bài viết mới. Các bài viết mới sẽ được viết dưới tổ chức KTMT. Bạn nào muốn viết blog cho KTMT có thể tham gia tổ chức KTMT trên Kipalog cùng chúng tôi.</p>
<h1 id="kết-luận">Kết luận</h1>
<p>Chúng tôi hy vọng bạn sẽ thích Kipalog. Trên hơn cả, chúng tôi hy vọng các bạn xem Kipalog <strong>không chỉ là nơi để đọc</strong>, mà còn là nơi các bạn <strong>tích cực chia sẻ</strong> vốn kiến thức của bản thân.</p>
<p>Cám ơn các bạn. Đón đọc những tri thức của bạn tại <a href="http://kipalog.com">kipalog.com</a> :)</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-03-08T12:56:00+09:00" data-updated="true" itemprop="datePublished">Mar 8<span>th</span>, 2015</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/other/'>other</a>


</div>
		
			<span class="comments"><a href="/blog/2015/03/08/ktmt-blog-nguon-mo/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/03/08/ktmt-blog-nguon-mo/" itemprop="url">KTMT: Blog Nguồn Mở</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<blockquote>
<p>“If you’re thinking without writing, you only think you’re thinking.” – Lessie Lamport</p>
</blockquote>
<h1 id="giới-thiệu">Giới thiệu</h1>
<p>Mình rất thích câu nói trên của Lamport. Đối với mình câu nói trên hay ở chỗ: vế sau của câu là một cách nói đệ quy. “Bạn chỉ nghĩ rằng là bạn đang suy nghĩ”. Suy nghĩ là để tìm ra câu trả lời cho một câu hỏi nào đó. Nhưng nếu không có việc viết lách, đối tượng của suy nghĩ sẽ chỉ đơn thuần là “sự suy nghĩ” - và chúc mừng bạn, bạn rơi vào vòng lặp đệ quy vô hạn. Cách duy nhất để bạn thoát khỏi vòng lặp đệ quy vô hạn của suy nghĩ là phải định nghĩa một điểm khởi đầu trong tư duy. Viết lách chính là điểm khởi đầu đó.</p>
<p>Blog ktmt cũng bắt đầu với một ý tuởng đơn giản như ở trên: một chỗ để các thành viên viết và chia sẻ cho những thành viên khác điều mình học đuợc. Bài viết không cần phức tạp, chỉ cần có nội dung liên quan đến kỹ thuật là được chấp nhận. “Muốn chia sẻ điều mình học đuợc?” - Hãy viết một bài về chủ đề đó và các thành viên khác sẽ đọc. Ý tuởng thì là vậy nhưng thực hiện đuợc nó thật sự rất gian nan. Khi thực sự viết ra, bọn mình mới thấy để viết đuợc một bài cần đầu tư rất nhiều thời gian, từ nghiên cứu cho đến viết code mẫu để demo cho bài viết. Tuy vậy nhờ việc viết ra những điều <em>mình tuởng là biết</em> bọn mình khám phá ra có rất nhiều chỗ bọn mình chưa thực sự <em>biết như mình tuởng</em>. Mỗi câu văn khó hiểu cho người đọc thật sự không chỉ do cách viết mà còn do sự thiếu tuờng tận và am hiểu về chủ đề đuợc viết. Cứ mỗi bài viết, bọn mình là đọc rất kỹ, kiểm tra cho nhau và đưa ra những góp ý sửa chữa cho nhau. Nhờ vậy am hiểu của ngưòi viết về chủ đề đang viết cũng như nguời đọc trở nên sâu sắc hơn.</p>
<p>Bọn mình đưa bài lên một blog chỉ đơn giản với mục đích cho các thành viên khác đọc và góp ý. Thế nhưng dần dần bọn mình nhân ra rằng không chỉ cá nhân nhóm tác giả mà còn rất nhiều bạn đọc khác cũng đọc và góp ý. Bài viết của bọn mình một phần nào đó đã đem lại ích lợi cho cho cộng đồng. Ngoài ra bọn mình cũng nhận được nhiều đóng góp cũng như câu hỏi từ bạn đọc. Những đóng góp và câu hỏi giúp bọn mình rất nhiều trong việc hiểu sâu sắc hơn chủ đề mỗi bài viết. Bọn mình nhận thấy bọn mình không những học đuợc lẫn nhau mà còn học đuợc từ rất nhiều bạn đọc khác - điều bọn mình rất vui.</p>
<p>Gần đây bọn mình nhận đuợc nhiều ý kiến đề xuất đóng góp bài viết. “Sao không!” là câu nói đầu tiên xuất hiện trong đầu của tất cả các thành viên blog ktmt. Đối với bọn mình đây là điều không gì vui hơn. Blog sẽ có nhiều bài viết mới từ nhiều góc độ suy nghĩ cũng như kiến thức hơn (và bọn mình sẽ có cơ hội học được từ nhiều ngưòi hơn). Các bạn tác giả sẽ có nơi để luyện tập viết lách. Độc giả sẽ có nhiều bài viết để đọc hơn. Sau khi cân nhắc nhiều yếu tố - hầu hết chỉ có lợi - bọn mình đi đến quyết định:</p>
<p>Biến ktmt trở thành một blog cộng đồng!</p>
<h1 id="mở-rộng-blog-ktmt">Mở rộng blog KTMT</h1>
<p>Blog ktmt sẽ không chỉ bao gồm bài viết của nhóm tác giả hiện tại mà sẽ nhận bài viết từ tất cả các bạn nào muốn đóng góp. Mỗi bài viết của KTMT đều đuợc viết bằng <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">ngữ pháp Markdown</a>, sử dụng <a href="http://octopress.org/">Octopress</a> để biên tập và chia sẻ trên máy chủ của <a href="http://github.com">github</a>. Về cách sử dụng các tool này các bạn có thể tham khảo: <a href="http://ktmt.github.io/blog/2013/04/30/huong-dan-su-dung-octopress-cho-blog-tren-github/">Blogging With Github and Octopress</a>. Để giữ blog không thay đổi quá nhiều ở giai đoạn đầu, bọn mình quyết định quy trình đóng góp bài viết như sau:</p>
<ul>
<li>Fork https://github.com/ktmt/ktmtblog-octopress/</li>
<li>Viết bài mới.</li>
<li>Tạo Pull Request đến repository của KTMT.</li>
<li>“Ban biên tập” sẽ tiến hành biên tập và góp ý công khai trên Pull Request.</li>
<li>Các bài viết đáp ứng đuợc yêu cầu sẽ được merge và đưa lên blog KTMT.</li>
</ul>
<p>Tiêu chí biên tập là điều bọn mình đã suy nghĩ nhưng vẫn chưa tìm ra đuợc những tiêu chí xác đáng. Vì vậy truớc mắt bọn mình tạm đề ra các tiêu chí biên tập như duới đây:</p>
<ul>
<li>Bài viết phải có nội dung về kỹ thuật và máy tính.</li>
<li>Bài viết nên đuợc viết bằng tiếng Việt và có bố cục rõ ràng.</li>
<li>Bài viết nên viết về chủ đề mà tác giả đã hoặc đang nghiên cứu.</li>
<li>Bài viết nên đuợc đầu tư thời gian về ý tuởng và cách diễn đạt.</li>
<li>Bài viết có tính mới mẻ và sáng tạo là hoàn hảo!</li>
<li>Bài viết nếu có mã nguồn demo thì càng tốt. Linux Torvalds đã từng nói: “Talk is cheap. Show me the code”. Mã nguồn chuơng trình chạy được sẽ như một bức tranh đáng giá hàng ngàn từ ngữ.</li>
</ul>
<p>Ngoài ra bọn mình cũng đã thiết lập <a href="https://www.facebook.com/groups/714123448709763/">một trang Facebook group của blog</a>. Các thảo luận xung quanh bài viết sẽ đuợc thực hiện thông qua page này.</p>
<h1 id="ban-biên-tập">Ban biên tập</h1>
<p>Trước mắt ban biên tập sẽ chỉ bao gốm những thành viên đóng góp thuờng xuyên của KTMT:</p>
<ul>
<li><a href="https://github.com/dtvd">dtvd</a></li>
<li><a href="https://github.com/huydx">huydx</a></li>
<li><a href="https://github.com/kiennt">kiennt</a></li>
<li><a href="https://github.com/viethnguyen">viethnguyen</a></li>
<li><a href="https://github.com/telescreen">telescreen</a></li>
</ul>
<p>Trong tuơng lai bọn mình muốn sẽ có những thành viên xuất sắc trong biên tập. Vì vậy bọn mình tạm đề ra một tiêu chí để tham gia ban biên tập như sau:</p>
<p><strong><em>“Là một thành viên đóng góp thuờng xuyên và có nhiều bài viết tốt cho blog KTMT”.</em></strong></p>
<p>Thành viên nào đóng góp đuợc 5 bài viết sẽ đuợc tính là thành viên thường xuyên. Về tiêu chí bài viết tốt, bọn mình hiện đang trong quá trình xây dựng cách đánh giá cho tiêu chí này.</p>
<h1 id="kết-thúc">Kết thúc</h1>
<p>Bọn mình mong chờ nhiều bài viết tốt hơn nữa từ các bạn!</p>
<h1 id="tham-khảo">Tham khảo</h1>
<ol type="1">
<li><a href="http://channel9.msdn.com/Events/Build/2014/3-642">Bài phát biểu của Lessie Lamport</a></li>
<li><a href="http://en.wikiquote.org/wiki/Linus_Torvalds">Những câu nói của Linus Torvalds</a></li>
</ol>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2015-02-15T04:04:00+09:00" data-updated="true" itemprop="datePublished">Feb 15<span>th</span>, 2015</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/functional/'>functional</a>, <a class='category' href='/blog/categories/haskell/'>haskell,</a>


</div>
		
			<span class="comments"><a href="/blog/2015/02/15/haskells-laziness/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2015/02/15/haskells-laziness/" itemprop="url">Haskell&#8217;s Laziness</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Trong bài viết này, tôi sẽ trình bày về một đặc tính của Haskell khá khác biệt so với các ngôn ngữ lập trình khác, đó là laziness (dịch tiếng việt nôm na là “luời biếng”, nhưng tôi xin đuợc giữ nguyên từ gốc tiếng anh).</p>
<p>Chúng ta hiểu laziness như thế naò? <code>Lazy evaluation</code> nghĩa là, việc evaluate các đối số của hàm sẽ đuợc trì hoãn càng lâu càng tốt, chúng sẽ không đuợc evaluate cho đến khi biểu thức thực sự cần đến gía trị của chúng. Khi một biểu thức đuợc đưa làm đối số cho một hàm, nó chỉ đuợc đóng gọn lại thành một biểu thức chưa đuợc đánh gía (unevaluated expression), mà chưa đuợc tính toán gì cả.</p>
<p>Chúng ta sẽ sử dụng Lecture 7 của course CIS 194 (<a href="http://www.cis.upenn.edu/~cis194/fall14/lectures/07-laziness.html">Link</a>) để minh họa cho việc tìm hiểu Laziness. Bên cạnh đó, tôi sẽ trình bày qua những syntax cơ bản của Haskell theo bài viết.</p>
<h1 id="tính-số-fibonacci">Tính số Fibonacci</h1>
<p>Trong bài tập thứ nhất, chúng ta sẽ viết một hàm <code>fib</code> để tính ra số Fibonacci thứ n</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="c1">-- Exercise 1 </span>
</span><span class='line'><span class="nf">fib</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
</span><span class='line'><span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">0</span>
</span><span class='line'><span class="nf">fib</span> <span class="mi">1</span> <span class="ow">=</span> <span class="mi">1</span>
</span><span class='line'><span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Bên trên là điển hình của cách viết một hàm (function) trong Haskell. Truớc tiên, chúng ta có tên hàm nằm truớc dấu <code>::</code>, trong truờng hợp này là hàm <code>fib</code>. Tiếp theo, nằm sau dấu <code>::</code>, chúng ta có <code>Integer -&gt; Integer</code>, đây chính là nơi khai báo đối số và giá trị trả về của Haskell. Trong truờng hợp này, hàm <code>fib</code> nhận đối số là Integer (số Fibonacci thứ mấy) và trả về Integer (số Fibonacci cần tìm). Tài liệu sau đây nói một cách khá đầy đủ về syntax viết function, bạn nên đọc thêm: <a href="http://learnyouahaskell.com/syntax-in-functions">Syntax in Functions</a></p>
<p>Sau dòng khai báo tên hàm và nguyên mẫu hàm là định nghĩa của một loạt pattern matching. Haskell sẽ match từ trên xuống duới, do vậy truớc tiên ta khai báo base case cho số Fibonacci thứ 0 và thứ 1. Các số Fibonacci tiếp theo, vì không match các base pattern nên sẽ sử dụng pattern thứ ba, cộng hai số Fibonacci phía truớc.</p>
<p>Chúng ta thấy cách khai báo pattern matching khá gần gũi vớí định nghiã dãy Fibonacci chúng ta đã học. Tiếp theo, ta định nghiã một dãy Fibonacci vô hạn như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="nf">fibs1</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
</span><span class='line'><span class="nf">fibs1</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">fib</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p><code>map</code> là một function trong Haskell, nhận vaò hai đối số là một hàm f và một danh sách. Nó sẽ trả về một danh sách mới mà các phần từ là kết qủa trả về tuơng ứng khi áp dụng hàm f với từng phần tử trong danh sách cũ. <code>[0..]</code> là cách viết danh sách tất cả các số nguyên duơng. Như vậy, ta có <code>fibs1</code> là danh sách tất cả các số Fibonacci.</p>
Hãy khởi động GHCi và check hàm mới này:
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'><span class="nv">$ </span>ghci
</span><span class='line'>Prelude&gt; :l HW07.hs
</span><span class='line'><span class="o">[</span>1 of 1<span class="o">]</span> Compiling HW07             <span class="o">(</span> HW07.hs, interpreted <span class="o">)</span>
</span><span class='line'>Ok, modules loaded: HW07.
</span><span class='line'>*HW07&gt; fibs1
</span><span class='line'><span class="o">[</span>0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Bạn sẽ thấy một vài số Fibonacci đầu tiên hiện ra rất nhanh, nhưng đến một lúc nào đó, sẽ rất lâu để tính đuợc số Fibonacci tiếp theo. Lý do là vì mỗi số Fibonacci bị tính đi tính lại quá nhiều lần!</p>
<p>Và đây là lúc chúng ta áp dụng Laziness của Haskell.</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="c1">-- Exercise 2 </span>
</span><span class='line'><span class="nf">fibs2</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span><span class="p">]</span>
</span><span class='line'><span class="nf">fibs2</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">++</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs2</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs2</span><span class="p">)</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Chúng ta đã biết dãy Fibonacci bắt đầu từ hai số 0, 1, nên ta khởi đầu khai baó dãy bằng 0,1.</p>
<p>Giả sử ta đã có một dãy Fibonacci vô hạn:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'><span class="o">[</span>0, 1, 1, 2, 3, 5, 8, 13, ...<span class="o">]</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p><code>tail</code> là phép toán bỏ đi phần tử đầu tiên của một dãy:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'><span class="o">[</span>1, 1, 2, 3, 5, 8, 13, ...<span class="o">]</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p><code>zipWith</code> kết hợp 2 dãy trên theo từng cặp phần tử sử dụng một phép toán naò đó (ở đây là phép cộng):</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'><span class="o">[</span>0, 1, 1, 2, 3, 5, 8, 13, ...<span class="o">]</span>
</span><span class='line'>+
</span><span class='line'><span class="o">[</span>1, 1, 2, 3, 5, 8, 13, ...<span class="o">]</span>
</span><span class='line'><span class="o">=</span>
</span><span class='line'><span class="o">[</span>1, 2, 3, 5, 8, 13, ...<span class="o">]</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Như vậy, dãy vô hạn Fibonacci có thể đuợc tính bằng cách thêm hai phần tử đầu tiên (0, 1) vào kết quả sau khi zip dãy Fibonacci vô hạn với <code>tail</code> của nó!</p>
<p>Và đây chính là sức mạnh của laziness! <code>fibs2</code> là kết quả trả về mà chúng ta lại có thể để xuất hiện ở bên vế phải! Haskell chỉ evaluate vế phải khi naò thực sự cần thiết, cho nên mỗi khi cần tính một phần tử mới cho dãy <code>fibs2</code>, nó mới quay ra tìm lại những phần tử đằng truớc (đã đuợc tính).</p>
Bạn hãy thử chạy lại <code>fibs2</code> với GHCi và quan sát, số Fibonacci tuôn ra như thác lũ :) Hãy thử chỉ lấy 100 số Fibonacci ban đầu xem:
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'>*HW07&gt; take 100 fibs2
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>100 số Fibonacci đầu tiên xuất hiện trong chớp mắt!</p>
<h1 id="streams">Streams</h1>
<p>Trong phần này, chúng ta định nghĩa kiểu dữ liệu (data type) <code>Stream</code>, gần giống với <code>list</code> nhưng bị ràng buộc là <em>phải vô hạn</em></p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">a</span><span class="p">)</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Bên trên là cách khai baó một kiểu dữ liệu, bắt đầu bằng từ khoá <code>data</code>. <code>Stream</code> là tên kiểu dữ liệu, tiếp sau đó đến truớc dấu <code>=</code> là <code>type variable</code>, tức là <code>a</code> có thể thay cho <code>Integer</code>, <code>String</code>, … và ta có kiểu dữ liệu <code>Stream Integer</code> hoặc <code>Stream String</code> tuơng ứng. Phiá sau dấu <code>=</code> là constructor của kiểu dữ liệu này: <code>Cons</code>, với 2 đối số thuộc kiểu <code>a</code> và <code>Stream a</code>. Bạn hãy tham khaỏ về cách taọ kiểu dữ liệu tại <a href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses">Link này</a></p>
<p>Hàm sau convert một stream thành list:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="nf">streamToList</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</span><span class='line'><span class="nf">streamToList</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">streamToList</span> <span class="n">s</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Trong exercise 4, chúng ta phải viết một instance của <code>Show</code> cho kiểu dữ liệu Stream. đến đây, chúng ta cần biết thêm về khái niệm <code>Typeclass</code> của Haskell. Typeclass có thể coi là một loại “giao diện”, nó định nghĩa một số loại hành vi, và các kiểu dữ liệu mà có cùng hành vi đó có thể được khai báo là instance của typeclass đó. Lấy ví dụ, <code>Eq</code> typeclass định nghĩa một giao diện cho những thứ có thể so sánh được. Cụ thể các hành vi mà nó định nghĩa như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
</span><span class='line'>    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'>    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Theo đó, bất cứ type nào muốn được là một instance của <code>Eq</code> typeclass sẽ phải khai báo các hàm <code>(==)</code>, <code>(/=)</code> (trên thực tế, chỉ cần khai báo một hàm, vì hàm còn lại được định nghĩa là phủ định của hàm kia).</p>
<p>Ví dụ, ta có một type như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Coin</span> <span class="ow">=</span> <span class="kt">Head</span> <span class="o">|</span> <span class="kt">Tail</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Chúng ta muốn <code>Coin</code> type là một instance của <code>Eq</code> typeclass thì ta làm như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Coin</span> <span class="kr">where</span>
</span><span class='line'>  <span class="kt">Head</span> <span class="o">==</span> <span class="kt">Head</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>  <span class="kt">Tail</span> <span class="o">==</span> <span class="kt">Tail</span> <span class="ow">=</span> <span class="kt">True</span>
</span><span class='line'>  <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Ở đây, chúng ta vẫn dùng pattern matching để định nghĩa hàm (==) với từng trường hợp của 2 đối số.</p>
<p>Quay trở lại với exercise 4, chúng ta định nghĩa <code>Stream a</code> thành một instance của <code>Show</code> typeclass như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="kr">instance</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Show</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
</span><span class='line'>    <span class="n">show</span> <span class="n">s</span> <span class="ow">=</span> <span class="n">show</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="p">(</span><span class="n">streamToList</span> <span class="n">s</span><span class="p">)</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Chúng ta thấy sự xuất hiện của kí tự “lạ”: <code>=&gt;</code>. Trong khai báo instance, những gì xuất hiện trước dấu <code>=&gt;</code> là những ràng buộc về type. Ở đây, chúng ta muốn <code>Stream a</code> là instance của <code>Show</code> thì bản thân <code>a</code>, một type variable, cũng phải là một instance của <code>Show</code>. Có như vậy, chúng ta mới định nghĩa được hàm <code>show</code> của <code>Show</code> typeclass cho <code>Stream a</code> dựa trên hàm <code>show</code> cho <code>a</code>.</p>
<p>Đến kí tự lạ tiếp theo: <code>$</code>. Đây chỉ đơn giản là một chỉ dẫn cho Haskell là tất cả những gì xuất hiện sau <code>$</code> có độ ưu tiên phép toán cao hơn, tức là <code>show $ take 20 (streamToList s)</code> tương đương với <code>show (take 20 (streamToList s))</code>. Nhưng chúng ta không muốn dùng quá nhiều dấu ngoặc, phải không :)</p>
<p>Trong định nghĩa hàm <code>show</code> cho <code>Stream a</code>, chúng ta không muốn nó in hết ra vô hạn phần tử, mà chỉ muốn in ra 20 phần tử đầu tiên. Do đó chúng chuyển nó thành list bằng hàm <code>streamToList</code>, lấy 20 phần tử đầu tiên bằng <code>take 20</code> và áp dụng hàm <code>show</code> cho <code>List a</code> type (khi <code>a</code> là instance của <code>Show</code> rồi thì <code>[a]</code> cũng là instance của <code>Show</code> )</p>
<p>Chúng ta phải có một vài <code>Stream</code> để test. Hãy định nghĩa chúng:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="nf">streamRepeat</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span>
</span><span class='line'><span class="nf">streamRepeat</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">x</span> <span class="p">(</span><span class="n">streamRepeat</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">streamMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">b</span>
</span><span class='line'><span class="nf">streamMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">streamMap</span> <span class="n">f</span> <span class="n">s</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">streamFromSeed</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span>
</span><span class='line'><span class="nf">streamFromSeed</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">x</span> <span class="p">(</span><span class="n">streamMap</span> <span class="n">f</span> <span class="p">(</span><span class="n">streamFromSeed</span> <span class="n">f</span> <span class="n">x</span><span class="p">))</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p><code>streamRepeat</code> tạo ra một stream chứa vô hạn các phần tử giống hệt nhau. <code>streamMap</code> áp dụng một hàm <code>(a-&gt;b)</code> lên tất cả các phần tử của một <code>Stream a</code> để nhận được một Stream mới: <code>Stream b</code>. Cuối cùng <code>streamFromSeed</code> là một cách khác để tạo ra một stream, bằng cách bắt đầu từ một “hạt giống” thuộc type <code>a</code>, cũng chính là phần tử đầu tiên của Stream, rồi liên tục sử dụng một hàm có kiểu <code>a-&gt;a</code> để tạo ra các phẩn tử tiếp theo.</p>
<p>Tôi sẽ để dành phần này cho độc giả chiêm nghiệm xem tại sao lại viết như vậy.</p>
<p>Bây giờ, chúng ta hãy cùng test thử những gì chúng ta đã viết trong GHCi</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'>*HW07&gt; show <span class="nv">$ </span>streamFromSeed <span class="o">(</span><span class="s1">&#39;x&#39;</span>:<span class="o">)</span> <span class="s2">&quot;o&quot;</span>
</span><span class='line'><span class="s2">&quot;[\&quot;o\&quot;,\&quot;xo\&quot;,\&quot;xxo\&quot;,\&quot;xxxo\&quot;,\&quot;xxxxo\&quot;,\&quot;xxxxxo\&quot;,\&quot;xxxxxxo\&quot;,\&quot;xxxxxxxo\&quot;,\&quot;xxxxxxxxo\&quot;,\&quot;xxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxo</span>
</span><span class='line'><span class="s2">\&quot;,\&quot;xxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxxxxxo\&quot;,</span>
</span><span class='line'><span class="s2">\&quot;xxxxxxxxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxxxxxxxo\&quot;,\&quot;xxxxxxxxxxxxxxxxxxxo\&quot;]&quot;</span>
</span><span class='line'>*HW07&gt; show <span class="nv">$ </span>streamRepeat <span class="s2">&quot;o&quot;</span>
</span><span class='line'><span class="s2">&quot;[\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;,\&quot;o\&quot;]&quot;</span>
</span><span class='line'>*HW07&gt; show <span class="nv">$ </span>streamMap <span class="o">(</span>+ 1<span class="o">)</span> <span class="o">(</span>streamRepeat 0<span class="o">)</span>
</span><span class='line'><span class="s2">&quot;[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]&quot;</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Như vậy ta đã có một số hàm để làm việc với <code>Stream</code>, ta sẽ thử định nghĩa dãy số tự nhiên bằng <code>Stream</code> như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="nf">nats</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="kt">Integer</span>
</span><span class='line'><span class="nf">nats</span> <span class="ow">=</span> <span class="n">streamFromSeed</span> <span class="p">(</span><span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
Test trong GHCi:
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre>
</td>
<td class="code">
<pre><code class='bash'><span class='line'>*HW07&gt; show nats
</span><span class='line'><span class="s2">&quot;[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]&quot;</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Ví dụ tiếp theo: Tính ruler function f(n) = số mũ lớn nhất của 2 là ước số của n. Bình thuờng chúng ta sẽ nghĩ đến việc chia 2 cho đến khi lẻ thì thôi. Nhưng tôi sẽ trình bày một lời giải khác, sử dụng laziness và cấu trúc dữ liệu vô hạn của Haskell.</p>
<p>Thay vì tính từng f(n) một, chúng ta sẽ xây dựng hẳn cả dãy số <code>ruler</code> f(n) với n bắt đầu từ 1: <code>0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4...</code>, trong đó phần tử thứ n trong stream là số mũ lớn nhất của 2 là ước số của n.</p>
<p>Dễ thấy có thể coi dãy trên là trộn xen kẽ của hai dãy, một dãy toàn 0 (vì tuơng ưng với n lẻ nên số mũ lớn nhất của 2 chỉ là 0) và dãy còn lại tuơng ứng với n chẵn. điều kì diệu là dãy thứ hai bao gồm chính các phần tử của dãy <code>ruler</code> nhưng cộng thêm 1 (Bạn thử suy nghĩ xem tại sao). Vì thế mà ta có cách khai báo <code>ruler</code> là một <code>Stream Integer</code> rất đẹp như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre>
</td>
<td class="code">
<pre><code class='haskell'><span class='line'><span class="nf">interleaveStreams</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">a</span>
</span><span class='line'><span class="nf">interleaveStreams</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x1</span> <span class="n">s1</span><span class="p">)</span> <span class="o">~</span><span class="p">(</span><span class="kt">Cons</span> <span class="n">x2</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">x1</span> <span class="p">(</span><span class="kt">Cons</span> <span class="n">x2</span> <span class="p">(</span><span class="n">interleaveStreams</span> <span class="n">s1</span> <span class="n">s2</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="nf">ruler</span> <span class="ow">::</span> <span class="kt">Stream</span> <span class="kt">Integer</span>
</span><span class='line'><span class="nf">ruler</span> <span class="ow">=</span> <span class="n">interleaveStreams</span> <span class="p">(</span><span class="n">streamRepeat</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="n">streamMap</span> <span class="p">(</span><span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ruler</span><span class="p">)</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Lại thêm một kí tự lạ: tilde sign <code>~</code>! Tôi đã thêm nó vào truớc đối số thứ hai của <code>interleaveStreams</code>. Kí tự này dùng để báo hiệu compiler đừng evaluate đối số thứ hai này. Nếu không có kí tự <code>~</code>, pattern matching của hàm <code>interleaveStream</code> sẽ phải evaluate đối số thứ hai để đảm bảo nó thuộc type <code>Stream a</code>. đó không phải là điều chúng ta muốn, vì hàm <code>ruler</code> gọi hàm <code>interleaveStream</code> với đối số thứ hai chứa <code>ruler</code>, tức là gọi đệ quy vô hạn lần. Nếu đối số thứ hai của <code>interleaveStream</code> không lazy, hàm này sẽ dừng mãi ở việc evaluate để phục vụ pattern matching.</p>
<p>Nói nôm na, thêm dấu <code>~</code> truớc một đối số là chúng ta đã bảo với compiler là: “đừng lo, tôi đảm bảo đối số này sẽ có kiểu Stream a, nên đừng evaluate làm gì” :)</p>
<h1 id="kết-luận">Kết luận</h1>
<p>Bài viết này đã trình bày một số ví dụ để minh họa lazy evaluation của Haskell. Nó cho phép ta làm việc với những kiểu cấu trúc dữ liệu <em>vô hạn</em>, một pattern khá thuờng gặp trong Haskell. Việc định nghiã một cấu trúc dữ liệu vô hạn thực chất chỉ taọ ra một biểu thức chưa đuợc evaluate, mà ta sử dụng nó để chỉ ra cấu trúc dữ liệu hoàn chỉnh “có thể” phát triển đến như thế naò, và chỉ phần naò cần thiết mới đuợc tính toán.</p>
<p>Tuy nhiên, chủ đề laziness là một chủ đề khá phức tạp, đặc biệt khi chúng ta muốn đánh giá time và space của program. Có khá nhiều bài viết trên mạng về vấn đề này, một trong số đó bạn có thể tham khảo thêm là:</p>
<ul>
<li><a href="https://hackhands.com/lazy-evaluation-works-haskell/">How Lazy Evaluation Works in Haskell</a></li>
</ul>
		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
        <a href="/blog/page/2/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    kỹ thuật máy tính


</footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ktmt';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-41828637-2', 'ktmt.github.io');
  ga('send', 'pageview');

</script>	


		</div>
	</div>
</body>
</html>

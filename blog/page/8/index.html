
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Blog kỹ thuật máy tính</title>
	<meta name="author" content="kỹ thuật máy tính">

	
	<meta name="description" content="Nov 3rd, 2013 Comments Full Text Search, Từ Khái Niệm đến Thực Tiễn (Phần 2) Introduction
Trong phần 1, chúng ta đã tìm hiểu sơ qua về khái niệm &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Blog kỹ thuật máy tính" type="application/atom+xml">
	
	<link rel="canonical" href="http://git@github.com.github.com/blog/page/8/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
  </script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	<script src="/javascripts/md5.js"></script>
	<img src='/images/logo.jpg' alt='Profile Picture' style='width: 160px;' />
</div>
<h1><a href="/">Blog kỹ thuật máy tính</a></h1>
<p class="subtitle">kỹ thuật máy tính</p>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="facebook" href="http://www.facebook.com/pages/ktmtgithubio/486208978117754" title="Facebook">Facebook</a>
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>
			</div>
		</div>
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-11-03T20:21:00+09:00" data-updated="true" itemprop="datePublished">Nov 3<span>rd</span>, 2013</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2013/11/03/full-text-search/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/11/03/full-text-search/" itemprop="url">Full Text Search, Từ Khái Niệm đến Thực Tiễn (Phần 2)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1 id="introduction">Introduction</h1>
<p>Trong <a href="http://ktmt.github.io/blog/2013/10/27/full-text-search-engine/">phần 1</a>, chúng ta đã tìm hiểu sơ qua về khái niệm Full Text Search, cũng như về Inverted Index. Qua bài viết đầu tiên, các bạn đã nắm được tại sao Inverted Index lại được sử dụng để tăng tốc độ tìm kiếm trong một “Full Text Database”. Đồng thời ở ví dụ của phần một, các bạn cũng đã thấy, để tạo ra Inverted Index thì các bạn phải tách được một string ra thành các <strong>term</strong>, sau đó sẽ index string đó theo term đã tách được. Chính vì thế việc <strong>tách string</strong>, hay còn gọi là <strong>Tokenize</strong> là một bài toán con quan trọng nằm trong bài toán lớn của Full Text Search. Ở bài này, chúng ta sẽ tìm hiểu về 2 kĩ thuật Tokenize cơ bản là:</p>
<ul>
<li>N-Gram</li>
<li>Morphological Analysis</li>
</ul>
<h1 id="n-gram">N-gram</h1>
<p>N-gram là kĩ thuật tokenize một chuỗi thành các chuỗi con, thông qua việc <strong>chia đều</strong> chuỗi đã có thành các chuỗi con đều nhau, có độ dài là N. Về cơ bản thì N thường nằm từ 1~3, với các tên gọi tương ứng là unigram(N==1), bigram(N==2), trigram(N==3). Ví dụ đơn giản là chúng ta có chuỗi “good morning”, được phân tích thành bigram:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class=''><span class='line'>"good morning" =&gt; {"go", "oo", "od", "d ", " m", "mo", "or", "rn", "ni", "in", "ng"}</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Từ ví dụ trên các bạn có thể dễ dàng hình dung về cách thức hoạt động của N-gram. Để implement N-gram, chỉ cần một vài ba dòng code như sau, như ví dụ viết bằng python như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre>
</td>
<td class="code">
<pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">split_ngram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">statement</span><span class="p">,</span> <span class="n">ngram</span><span class="p">):</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ngram</span><span class="p">):</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">statement</span><span class="p">)</span> <span class="o">-</span> <span class="n">ngram</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
</span><span class='line'>        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">statement</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">ngram</span><span class="p">])</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<h1 id="morphological-analysis">Morphological Analysis</h1>
<p>Morphological Analysis, rất may mắn có định nghĩa trên [wikipedia](http://vi.wikipedia.org/wiki/H%C3%ACnh_th%C3%A1i_h%E1%BB%8Dc_(ng%C3%B4n_ng%E1%BB%AF_h%E1%BB%8Dc) bằng tiếng Việt. Định nghĩa khá dài dòng, các bạn có thể xem bằng [Tiếng Anh](http://en.wikipedia.org/wiki/Morphology_(linguistics) Về cơ bản Morphological Analysis (từ bây giờ mình sẽ gọi tắt là MA), là một kĩ thuật phổ biến trong xử lý ngôn ngữ tự nhiên (Natural Language Processing). Morphological chính là “cấu trúc” của từ, như vậy MA sẽ là “phân tích cấu trúc của từ”, hay nói một cách rõ ràng hơn, MA sẽ là kĩ thuật tokenize mà để tách một chuỗi ra thành các từ có ý nghĩa. Ví dụ như cũng cụm từ “good morning” ở trên, chúng ta sẽ phân tích thành:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='python'><span class='line'><span class="s">&quot;good morning&quot;</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="s">&quot;good&quot;</span><span class="p">,</span> <span class="s">&quot;morning&quot;</span><span class="p">}</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Để có được kết quả phân tích như trên, ngoài việc phải sở hữu một bộ từ điển tốt (để phân biệt được từ nào là có ý nghĩa, và thứ tự các từ thế nào thì có ý nghĩa), MA phải sử dụng các nghiên cứu sâu về xử lý ngôn ngữ tự nhiên, mà mình sẽ không đi sâu ở đây. Thông thường các công ty lớn sở hữu các search engine của riêng họ(như Yahoo, Google, Microsoft..) sẽ có các đội ngũ nghiên cứu để tạo ra nhiều bộ thư viện MA riêng của họ, thích hợp với nhiều ngôn ngữ. Ngoài ra chúng ta cũng có thể sử dụng các bộ thư viện được open source, hoặc sử dụng các package có sẵn trong các bộ full text search engine mà tiêu biểu là lucene.</p>
<h1 id="mở-rộng">Mở rộng</h1>
<p>Các bạn đọc đến đây chắc hẳn sẽ có suy nghĩ, để phân tách chuỗi, thì rõ ràng phân tích theo MA là quá hợp lý rồi, tại sao lại cần N-gram làm gì? Như mình đã nói ở trên, để xây dựng MA thì cần một bộ từ điển tốt, để giúp cho máy tính có thể phân biệt được các từ có nghĩa. Như thế nào là một từ điển tốt, thì về cơ bản, từ điển tốt là từ điển chứa càng nhiều từ (terms) càng tốt. Tuy nhiên ngôn ngữ thì mỗi ngôn ngữ lại có đặc trưng riêng, và không ngừng mở rộng, không ngừng thêm các từ mới. Việc chỉ sử dụng MA sẽ gây ra một tác dụng phụ là có rất nhiều từ không/chưa có trong từ điển, dẫn đến không thể index, và do đó sẽ không thể tiến hành tìm kiếm từ đó được.</p>
<p>Vậy cách giải quyết như thế nào? Cách giải quyết tốt nhất là chúng ta sẽ <strong>kết hợp(hybrid)</strong> cả MA và N-gram. Cách hybrid thế nào thì sẽ tuỳ vào ngôn ngữ/ hoàn cảnh sử dụng, và cả performance cần thiết nữa. Về cơ bản thì những từ nào khó/không có thể phân tích được bằng MA, thì chúng ta sẽ dùng N-gram.</p>
<h1 id="kết-luận">Kết luận</h1>
<p>Qua bài viết lần này, các bạn đã hiểu thêm về 2 kĩ thuật tách từ (tokenize) cơ bản là N-gram và MA.</p>
<p>Sử dụng 2 kĩ thuật này như thế nào để index dữ liệu đầu vào, sẽ được giới thiệu trong các bài viết sắp tới.</p>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-11-03T19:35:00+09:00" data-updated="true" itemprop="datePublished">Nov 3<span>rd</span>, 2013</time></div>
		<div class="tags">

</div>
		
			<span class="comments"><a href="/blog/2013/11/03/aloha-protocol/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/11/03/aloha-protocol/" itemprop="url">Về Sự Bất ổn định Của Giao Thức ALOHA</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1 id="mở-đầu">1. Mở đầu</h1>
<p>Lý thuyết xác suất là một phân nhánh của toán học liên quan đến việc phân tích, đánh giá các sự kiện ngẫu nhiên. Một trong những ngành mà lý thuyết xác suất được sử dụng rất nhiều là truyền thông (communication). Bài viết này sẽ trình bày một ứng dụng của lý thuyết xác suất trong việc đánh giá độ tin cậy của giao thức ALOHA.</p>
<p>Một chút về lịch sử: ALOHA là hệ thống mạng máy tính đầu tiên, được phát triển ở đại học Hawaii. ALOHA được đưa vào sử dụng năm 1971, trở thành hình mẫu đầu tiên của mạng không dây truyền gói dữ liệu (wireless packet data network).</p>
<h1 id="tại-sao-giao-thức-aloha-được-coi-là-thiếu-ổn-định">2. Tại sao giao thức ALOHA được coi là thiếu ổn định?</h1>
<p>Trong phần này, dựa trên lý thuyết xác suất, chúng ta sẽ chứng minh sự thiếu ổn định của giao thức ALOHA.</p>
<p>Xét một communications facility ở đó: chia thời gian thành các slot có cùng period, số lượng bản tin đến tại thời điểm đầu mỗi slot n = 1, 2, … là các biến ngẫu nhiên độc lập với nhau và phân bố đồng dạng (indepedent and identically distributed). Đặt <strong>ai</strong> = P{có i bản tin đến} và giả sử rằng <strong>a0 + a1 &lt; 1</strong>, tức là vẫn có khả năng nhiều hơn 2 bản tin sẽ đến. Mỗi bản tin đến sẽ được truyền đi tại cuối slot mà nó đến. Nếu có đúng một bản tin được truyền đi, việc truyền tin thành công và bản tin sẽ rời khỏi hệ thống. Trong trường hợp ngược lại, nếu cuối một slot nào đó, ít nhất 2 bản tin đồng thời được truyền, sẽ xảy ra xung đột và những bản tin này vẫn ở lại trong hệ thống. Khi một bản tin gặp xung đột, nó sẽ độc lập với các bản tin khác truyền đi tại cuối slot tiếp theo với xác suất p. Ta sẽ chứng minh hệ thống như vậy sẽ không ổn định theo nghĩa: số lượng các lần truyền tin thành công là hữu hạn, với xác suất là 1.</p>
<p>Đặt <strong>Xn</strong> là số lượng bản tin trong hệ thống tại bắt đầu slot thứ n. Để ý rằng <strong>{Xn, n &gt; = 0}</strong> là một chuỗi Markov. Đưa vào một biến <strong>Ik</strong> như sau:</p>
<p><code>**Ik = 1**, nếu lần đầu tiên chuỗi rời trạng thái k, nó sẽ đi trực tiếp sang trạng thái k-1. **Ik = 0** trong các trường hợp còn lại, bao gồm cả trường hợp hệ thống không bao giờ ở trạng thái k.</code> Lấy ví dụ, nếu chuỗi Markov là 0, 1, 3, 4… thì <strong>I3 = 0</strong> do khi chuỗi rời khỏi trạng thái 3 thì nó sẽ đi sang trạng thái 4, không phải trạng thái 2. Ngược lại, nếu chuỗi là 0, 3, 3, 2, … thì <strong>I3 = 1</strong> vì ở lần đầu tiên nó đi ra khỏi trạng thái 3 thì nó sẽ sang trạng thái 2. Hiểu một cách đơn giản, biến Ik là một biến xác định tại trạng thái k, hệ thống có gửi được bản tin nào đi không, nếu gửi được thì hệ thống nhảy sang trạng thái k-1 và biến Ik nhận giá trị 1 (true).</p>
<p>Bây giờ ta tính giá trị trung bình (mean) sau:</p>
<p><img src="/images/aloha/eq1.gif"></p>
<p>Bây giờ, <strong>P{Ik = 1 | k is ever visited}</strong> là xác suất khi rời khỏi trạng thái k, trạng thái tiếp theo sẽ là k-1. Đây là xác suất có điều kiện của sự kiện: chuyển trạng thái từ k sang k-1, biết rằng hệ thống sẽ không quay trở lại trạng thái k. Do đó:</p>
<p><img src="/images/aloha/eq2.gif"></p>
<p>Ở đây, <strong>P{i,j}</strong> là xác suất của chuỗi Markov chuyển từ trạng thái i sang trạng thái j. Ta tính <strong>P{k,k-1}</strong> như sau: nhận thấy nếu có k bản tin ở đầu một slot thì sẽ có k-1 bản tin ở đầu slot tiếp theo nếu không có bản tin nào đến ở slot đó và chỉ có đúng một trong số k bản tin được truyền đi. Như vậy:</p>
<p><img src="/images/aloha/eq3.gif"></p>
<p>Đối với <strong>P{k,k}</strong>: nếu có k bản tin ở đầu một slot thì sẽ có k bản tin ở đầu slot tiếp theo nếu:</p>
<ul>
<li><p>không có bản tin nào đến và không xảy ra trường hợp: chỉ có đúng một trong số k bản tin được truyền đi. Tức là có thể không có bản tin nào truyền đi, như vậy vẫn chỉ có k bản tin. Hoặc là có 2 bản tin trở lên được truyền đi, nhưng như thế lại có xung đột và các bản tin này không được truyền và vẫn nằm nguyên trong hệ thống.</p></li>
<li><p>có đúng một bản tin đến (và nó sẽ tự động được truyền đi) và không có bất cứ bản tin nào trong số k bản tin được truyền.</p></li>
</ul>
<p>Đưa vào công thức, ta có:</p>
<p><img src="/images/aloha/eq4.gif"></p>
<p>Tổng kết lại, ta có:</p>
<p><img src="/images/aloha/eq5.gif"></p>
<p>Trong công thức trên, để ý khi k đủ lớn, mẫu số của biểu thức sẽ hội tụ về <strong>1-a0</strong>, còn trên tử số ta có:</p>
<p><img src="/images/aloha/eq6.gif"></p>
<p>Do đó, giá trị trung bình (mean) của tổng tất cả <strong>Ik</strong> sẽ nhỏ hơn vô cùng. Điều đó chứng tỏ, tổng tất cả các <strong>Ik</strong> sẽ nhỏ hơn vô cùng với xác suất là 1 (vì ngược lại, nếu có xác suất dương là tổng này có thể bằng vô cùng, thì giá trị trung bình của nó sẽ phải là vô cùng). Như vậy, với xác suất là 1, sẽ chỉ có hữu hạn trạng thái mà chuỗi Markov có thể rời khỏi nhờ truyền bản tin thành công. Cũng có nghĩa là, sẽ có một số nguyên hữu hạn N nào đó, mà khi có ít nhất N bản tin trong hệ thống, sẽ không thể có truyền tin thành công nào nữa. Xác suất có ít nhất 2 bản tin đến là dương, trong trường hợp đó, hệ thống sẽ không có bản tin nào truyền đi cả, và số lượng bản tin sẽ tăng lên ít nhất 2 bản tin. Vậy nên, hệ thống cuối cùng sẽ đạt đến trạng thái có ít nhất N bản tin ở trên, và không thể có truyền tin thành công nữa.</p>
<p>Vậy là ta đã thấy, giao thức ALOHA, trên phương diện lý thuyết xác suất, không ổn định về đảm bảo truyền tin thành công.</p>
<h1 id="tài-liệu-tham-khảo">Tài liệu tham khảo</h1>
<ol type="1">
<li>Introduction to Probability Models - Sheldon Ross</li>
</ol>
		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-10-27T22:21:00+09:00" data-updated="true" itemprop="datePublished">Oct 27<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/lucene/'>lucene</a>, <a class='category' href='/blog/categories/search-engine/'>search-engine</a>, <a class='category' href='/blog/categories/solr/'>solr</a>


</div>
		
			<span class="comments"><a href="/blog/2013/10/27/full-text-search-engine/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/10/27/full-text-search-engine/" itemprop="url">Full Text Search, Từ Khái Niệm đến Thực Tiễn (Phần 1)</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h1 id="lời-nói-đầu">Lời nói đầu</h1>
<p>Là một lập trình viên mà đã từng phải thao tác với cơ sở dữ liệu, hay đơn thuần là đã từng là một trang web bán hàng ,chắc hẳn các bạn đã từng nghe qua về khái niệm “Full text search”. Khái niệm này đã được định nghĩa khá cụ thể và đầy đủ trên <a href="http://en.wikipedia.org/wiki/Full_text_search">wikipedia</a>. Nói một cách đơn giản, “Full text search” là kĩ thuật tìm kiếm trên “Full text database”, ở đây “Full text database” là cơ sở dữ liệu chứa “toàn bộ” các kí tự (text) của một hoặc một số các tài liệu, bài báo.. (document), hoặc là của websites. Trong loạt bài viết này, mình sẽ giới thiệu về Full Text Search, từ khái niệm đến ứng dụng thực tiễn của kĩ thuật này. Chuỗi bài viết không nhằm giúp bạn tìm hiểu cụ thể về Full Text Search technique trong MySQL, Lucene hay bất kì search engine nào nói riêng, mà sẽ giúp bạn hiểu thêm vầ bản chất của kĩ thuật này nói chung. Ở bài viết cuối cùng, mình sẽ cùng các bạn implement thử một “Full Text Search engine” sử dụng python, qua đó giúp các bạn nắm rõ hơn cốt lõi của vấn đề.</p>
<p>Trong phần đầu tiên mình sẽ giới thiệu về định nghĩa của Full text search, và khái niệm cơ bản nhất trong Full Text Search, đó là Inverted Index.</p>
<h1 id="introduction">Introduction</h1>
Chắc hẳn các bạn đã từng dùng qua một kĩ thuật tìm kiếm rất cơ bản, đó là thông qua câu lệnh <strong>LIKE</strong> của SQL.
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre>
</td>
<td class="code">
<pre><code class='sql'><span class='line'><span class="k">SELECT</span> <span class="k">column_name</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="k">FROM</span> <span class="k">table_name</span>
</span><span class='line'><span class="k">WHERE</span> <span class="k">column_name</span> <span class="k">LIKE</span> <span class="n">pattern</span><span class="p">;</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Sử dụng <strong>LIKE</strong>, các bạn sẽ chỉ phải tìm kiếm ở column đã định trước, do đó lượng thông tin phải tìm giới hạn lại chỉ trong các column đó. Câu lệnh LIKE cũng tương đương với việc bạn matching pattern cho “từng” chuỗi của từng dòng (rows) của field tương ứng, do đó về độ phức tạp sẽ là tuyến tính với số dòng, và số kí tự của từng dòng, hay chính là “toàn bộ kí tự chứa trong field cần tìm kiếm”. Do đó sử dụng <strong>LIKE</strong> query sẽ có 2 vấn đề: - 1) Chỉ search được trong row đã định trươc - 2) Performance không tốt.</p>
<p>Như vậy chúng ta cần một kĩ thuật tìm kiếm khác, tốt hơn <strong>LIKE</strong> query, mềm dẻo hơn, tốt về performance hơn, đó chính là <strong>Full text searchi</strong>.</p>
<h1 id="cơ-bản-về-kĩ-thuật-full-text-search">Cơ bản về kĩ thuật Full text search</h1>
<p>Về mặt cơ bản, điều làm nên sự khác biệt giữa Full text search và các kĩ thuật search thông thường khác chính là “Inverted Index”. Vậy đầu tiên chúng ta sẽ tìm hiểu về Inverted Index</p>
<h2 id="inverted-index-là-gì">Inverted Index là gì</h2>
<p>Inverted Index là kĩ thuật thay vì index theo đơn vị row(document) giống như <a href="http://dev.mysql.com/doc/refman/5.0/en/mysql-indexes.html">mysql</a> thì chúng ta sẽ tiến hành index theo đơn vị term. Cụ thể hơn, Inverted Index là một cấu trúc dữ liệu, nhằm mục đích map giữa <strong>term</strong>, và <strong>các document chứa term đó</strong></p>
Hãy xem ví dụ cụ thể dưới đây, chúng ta có 3 documents D1, D2, D3
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre>
</td>
<td class="code">
<pre><code class='sql'><span class='line'><span class="n">D1</span> <span class="o">=</span> <span class="ss">&quot;This is first document&quot;</span>
</span><span class='line'><span class="n">D2</span> <span class="o">=</span> <span class="ss">&quot;This is second one&quot;</span>
</span><span class='line'><span class="n">D3</span> <span class="o">=</span> <span class="ss">&quot;one two&quot;</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Inverted Index của 3 documents đó sẽ được lưu dưới dạng như sau:</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre>
</td>
<td class="code">
<pre><code class='sql'><span class='line'><span class="ss">&quot;this&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="err">}</span>
</span><span class='line'><span class="ss">&quot;is&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="err">}</span>
</span><span class='line'><span class="ss">&quot;first&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D1</span><span class="err">}</span>
</span><span class='line'><span class="ss">&quot;document&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D1</span><span class="err">}</span>
</span><span class='line'><span class="ss">&quot;second&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D2</span><span class="err">}</span>
</span><span class='line'><span class="ss">&quot;one&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D2</span><span class="p">,</span> <span class="n">D3</span><span class="err">}</span>
</span><span class='line'><span class="ss">&quot;two&quot;</span> <span class="o">=&gt;</span> <span class="err">{</span><span class="n">D3</span><span class="err">}</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Từ ví dụ trên các bạn có thể hình dung được về thế nào là Inverted Index. Vậy việc tạo index theo term như trên có lợi thế nào? Việc đầu tiên là inverted index giúp cho việc tìm kiếm trên full text database trở nên nhanh hơn bao giờ hết. Hãy giả sử bạn muốn query cụm từ “This is first”, thì thay vì việc phải scan từng document một, bài toán tìm kiếm document chứa 3 term trên sẽ trở thành phép toán <strong>union</strong> của 3 tập hợp (document sets) của 3 term đó trong inverted index.</p>
<div class="bogus-wrapper">
<notextile>
<figure class="code">
<figcaption>
<span></span>
</figcaption>
<div class="highlight">
<table>
<tr>
<td class="gutter">
<pre class="line-numbers"><span class='line-number'>1</span>
</pre>
</td>
<td class="code">
<pre><code class='sql'><span class='line'><span class="err">{</span><span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="err">}</span> <span class="k">union</span> <span class="err">{</span><span class="n">D1</span><span class="p">,</span> <span class="n">D2</span><span class="err">}</span> <span class="k">union</span> <span class="err">{</span><span class="n">D1</span><span class="err">}</span> <span class="o">=</span> <span class="err">{</span><span class="n">D1</span><span class="err">}</span>
</span></code></pre>
</td>
</tr>
</table>
</div>
</figure>
</notextile>
</div>
<p>Một điểm lợi nữa chính là việc inverted index cực kì flexible trong việc tìm kiếm. Query đầu vào của bạn có thể là “This is first”, “first This is” hay “This first is” thì độ phức tạp tính toán của phép union kia vẫn là không đổi.</p>
<p>Như vậy chúng ta đã hiểu phần nào về khái niệm “Thế nào là Inverted Index”. Trong phần tiếp theo chúng ta sẽ tìm hiểu về cụ thể về cách implement của inverted index, và ứng dụng của inverted index vào việc tìm kiếm thông tin thông qua các kĩ thuật chính như: <strong>tokenization technique</strong> (thông qua N-Gram hoặc Morphological Analysis), <strong>query technique</strong> và <strong>scoring technique</strong>.</p>
		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/7/" class="prev">Prev</a>
    
    
        <a href="/blog/page/9/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    kỹ thuật máy tính


</footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ktmt';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-41828637-2', 'ktmt.github.io');
  ga('send', 'pageview');

</script>	


		</div>
	</div>
</body>
</html>

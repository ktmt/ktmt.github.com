
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Blog kỹ thuật máy tính</title>
	<meta name="author" content="kỹ thuật máy tính">

	
	<meta name="description" content="Apr 14th, 2013 javascript, programming Comments Giới Thiệu về Script Loader Trong Js I.Script loader là gì và tại sao lại cần nó Trong javascript, &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Blog kỹ thuật máy tính" type="application/atom+xml">
	
	<link rel="canonical" href="http://ktmt.github.com/blog/page/6/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	
</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<img src='/images/logo.jpg' alt='Profile Picture' style='width: 160px;' />
</div>
<h1><a href="/">Blog kỹ thuật máy tính</a></h1>
<p class="subtitle">kỹ thuật máy tính</p>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-04-14T00:23:00+09:00" data-updated="true" itemprop="datePublished">Apr 14<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/javascript/'>javascript</a>, <a class='category' href='/blog/categories/programming/'>programming</a>


</div>
		
			<span class="comments"><a href="/blog/2013/04/14/gioi-thieu-ve-script-loader-trong-js/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/04/14/gioi-thieu-ve-script-loader-trong-js/" itemprop="url">Giới Thiệu về Script Loader Trong Js</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>I.Script loader là gì và tại sao lại cần nó</h2>

<p>Trong javascript, khi cần include một thư viện, hay một module từ ngoài vào, chắc hản mọi
web developer đều nghĩ ngay đến việc include vào html:</p>

<figure class='code'><figcaption><span>include direct - include.html </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'> <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;http://yourhost/script.js&quot;</span> <span class="nt">&gt;&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vậy include trực tiếp script tag vào html có gì không tốt?</p>

<ul>
<li><p>Block việc render GUI của web browser:
Cơ chế render của web browser là render tuần tự, đi từ trên xuống dưới.Chính vì thế mà khi
gặp script tag thì đầu tiên là web browser phải download về, sau đó parse và execute script đó
, sau đó mới render những thứ tiếp theo. Việc này làm cho việc render nội dung web sẽ bị block lại
. Thử hình dung bạn sử dụng thư viện ember.js, thư viện này sau khi minified lại có dung lượng khoảng
200kb, bạn download từ cdn về mất 1.5s, bạn render mất 0.5s nữa, tổng cộng đã mất 2s, là một con số
không nhỏ.</p></li>
<li><p>Khi qui mô của web lớn lên, đặc biệt tại thời điểm mà các framework mvc cho js nở rộ như hiện
nay với ember, backbone hay angular và việc phát triển bùng phát của single-page web app(những
application viết chủ yếu bằng javascript) thì việc quản lý chặt chẽ thư viện, module nào có dependency
ra sao, nên được load vào thời điểm nào là hết sức quan trọng</p></li>
</ul>


<p>Để giải quyết vấn đề đó, thì chúng ta sẽ sử dụng một khái niệm gọi là script loader. Script loader chỉ
đơn giản là chuyển việc load script từ html vào một cái script js chỉ chuyên làm nhiệm vụ &#8220;load&#8221; các
dependent scripts. &#8220;load&#8221; bằng cách nào thì rất đơn giản, chỉ là tạo ra một script tag, gán source
và insert vào dom. Việc này khác việc include script bằng html là nó không block UI, nó chỉ đơn thuần
là request đến server chứa script cần load thông qua XHR, lấy kết quả về, và eval đoạn script đó.</p>

<p>Ví dụ về script loader:</p>

<figure class='code'><figcaption><span>script loader demo - loader.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">scList</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">();</span>
</span><span class='line'>  <span class="nx">scList</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;http://cdnjs.cloudflare.com/ajax/libs/ace/0.2.0/ace.js&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">scList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;http://cdnjs.cloudflare.com/ajax/libs/alloy-ui/1.0.1/aui-min.js&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">scList</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;http://cdnjs.cloudflare.com/ajax/libs/barman/0.2.2/barman.min.js&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">scList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">);</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">firstScript</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">scList</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
</span><span class='line'>    <span class="nx">firstScript</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">script</span><span class="p">,</span> <span class="nx">firstScript</span><span class="p">);</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'><span class="p">})()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Và kết quả đạt được là:</p>

<ol>
<li><p>Load script trực tiếp vào html tag
<img src="/images/script-loader-images/withoutloader.png" title="image" alt="images"></p></li>
<li><p>Load script thông qua loader
<img src="/images/script-loader-images/withloader.png" title="image" alt="images"></p></li>
</ol>


<p>Có được kết quả trên là vì đưa việc loading js vào trong script giúp cho ta có thể load các module
đó asynchronousi thông qua XHR(ajax), và nhờ đó rút ngắn được thời gian load + render
Như vậy là ta đã giải quyết được bài toán thứ nhất, tuy nhiên có một vấn đề là để load được một module
thông qua script loader thì module đó bắt buộc phải tuân theo một qui chuẩn nào đó để giúp qui định
về thứ tự load, và dependency. Để giải quyết vấn đề đó, đồng thời cũng để giải quyết vấn đề thứ hai đã
nêu ở trên chúng ta sẽ đưa ra khái niệm AMD</p>

<h2>II AMD</h2>

<p>AMD là viết tắt của Asynchronous Module Definition, là một qui chuẩn của javascript dành cho việc load
các script/module và các dependency của chúng từ ngoài vào một cách không đồng bộ (asynchronously).</p>

<p>Thực tế gọi là một qui chuẩn, nhưng AMD chỉ đơn thuần qui định 2 rule cơ bản:</p>

<ul>
<li>Interface cho hàm define()</li>
</ul>


<figure class='code'><figcaption><span>define define.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'> <span class="nx">define</span><span class="p">(</span><span class="nx">id</span><span class="o">?</span><span class="p">,</span> <span class="nx">dependencies</span><span class="o">?</span><span class="p">,</span> <span class="nx">factory</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>param id: qui định id của module được load vào, [?] là do param này là optional, có thể bỏ qua</li>
<li>param dependencies: là 1 <strong>array</strong> các module dependency của module được load vào, param này cũng là optional</li>
<li>param factory: là đoạn script dùng để initialze cho module sẽ được load vào. factory() sẽ chỉ được execute một lần
, và nếu factory() có return value thì return value này nên được export ra ngoài để có thể sử dụng lại ở trong các
script khác</li>
</ul>


<p>Một ví dụ đơn giản cho AMD interface:</p>

<figure class='code'><figcaption><span>amd if - amd.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">define</span><span class="p">([</span><span class="s2">&quot;alpha&quot;</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">alpha</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">verb</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>      <span class="k">return</span> <span class="nx">alpha</span><span class="p">.</span><span class="nx">verb</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Property amd cho hàm define:
Function define <strong>nên</strong> có property tên là amd. Việc này giúp tránh conflict khi module của bạn đã có một function tên
là define, và trong property này sẽ định nghĩa là module của bạn có cho phép nhiều version trên cùng một document không
( khi module của bạn đã conform theo AMD, thì chắc chắn trong hàm require phải có đoạn check là đã có property
này hay chưa  và check giá trị của nó).</li>
</ul>


<figure class='code'><figcaption><span>amd - amd.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">define</span><span class="p">.</span><span class="nx">amd</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">multiversion</span><span class="o">:</span> <span class="kc">true</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nói đến đây thì chấc sẽ có bạn thắc mắc, hoặc chưa hiểu rõ use case của cái AMD này như thế nào, nó được dùng ở đâu, ở script
loader, ở module, hay ở dom. Câu trả lời là AMD sẽ được dùng ở script loader và ở module. Cụ thể hơn là trong module của bạn,
nếu bạn muốn module đó được load async thông qua script loader, mà script loader đó lại load theo chuẩn AMD, thì đương nhiên
module của bạn cũng sẽ phải conform theo AMD, bằng cách là có hàm define() trong module, và có property amd của hàm define.
Còn script loader bản thân cũng là một module, thì tất nhiên cũng phải tuân theo AMD.</p>

<p>Một cách ngắn gọn, giả sử bạn có một module X</p>

<figure class='code'><figcaption><span>module - module.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">X</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'>  <span class="k">return</span> <span class="nx">prop</span><span class="p">;</span>
</span><span class='line'><span class="p">})()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Bạn muốn module đó nói với bên ngoài là: tao lã X, tao có các dependency là Y, Z, khi init tao thì mày làm thế này, thế này nhé
thì bạn sẽ làm theo AMD api theo cách như sau:</p>

<figure class='code'><figcaption><span>module with amd module.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">X</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">prop</span> <span class="o">=</span> <span class="p">{};</span>
</span><span class='line'>  <span class="nx">prop</span><span class="p">.</span><span class="nx">define</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">deps</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span><span class="c1">//do something to init here}</span>
</span><span class='line'>  <span class="nx">prop</span><span class="p">.</span><span class="nx">define</span><span class="p">.</span><span class="nx">amd</span> <span class="o">=</span> <span class="p">{</span><span class="nx">multiversion</span><span class="o">:</span> <span class="kc">true</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="nx">prop</span><span class="p">;</span>
</span><span class='line'><span class="p">})()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Và khi script loader nhìn vào cái define của bạn, nó sẽ biêt nên làm thê nào. Rất đơn giản phải không.</p>

<h2>III Các scriptloader nổi tiếng và việc áp dụng AMD đang ở đâu</h2>

<p>Hiện nay, có một số script loader nổi tiếng như:</p>

<ul>
<li>YepNope: http://yepnopejs.com/</li>
<li>RequireJs: http://requirejs.org/docs/</li>
<li>Headjs: https://github.com/headjs/headjs</li>
<li>CurlJs: https://github.com/cujojs/curl
Ngoài ra trong bộ toolkit nổi tiếng Dojo cũng có sử dụng script loader</li>
</ul>


<p>Trong những script ở trên thì có requirejs và curljs là sử dụng AMD, còn lại 2 script còn lại là yepnope
và headjs thì không. Về số lượng được sử dụng nhiều nhất thì có lẽ là requirejs.</p>

<p>Hiện tại các module nổi tiếng thì không phải module nào cũng conform theo AMD. Theo mình biết thì hiện
tại có jQuery là support AMD internally, còn lại thì phần nhiều các module nổi tiếng khác như backbone, ember,
angular đểu không support AMD internally. Để sử dụng các module này với một script loader theo chuẩn AMD
như require.js thì bạn đơn giản chỉ cần viết lại hàm define tại app của bạn, ví dụ như trong trường hợp của
backbone:</p>

<figure class='code'><figcaption><span>backbone with amd - bbamd.js </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">require</span><span class="p">.</span><span class="nx">config</span><span class="p">({</span>
</span><span class='line'>  <span class="nx">paths</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">jquery</span><span class="o">:</span> <span class="s1">&#39;libs/jquery/jquery&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">underscore</span><span class="o">:</span> <span class="s1">&#39;libs/underscore/underscore&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">backbone</span><span class="o">:</span> <span class="s1">&#39;libs/backbone/backbone&#39;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="nx">require</span><span class="p">([</span>
</span><span class='line'>    <span class="c1">// Load our app module and pass it to our definition function</span>
</span><span class='line'>    <span class="s1">&#39;app&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="p">],</span> <span class="kd">function</span><span class="p">(</span><span class="nx">App</span><span class="p">){</span>
</span><span class='line'>      <span class="c1">// The &quot;app&quot; dependency is passed in as &quot;App&quot;</span>
</span><span class='line'>      <span class="nx">App</span><span class="p">.</span><span class="nx">initialize</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Vậy tại sao AMD có rất nhiều merit như thê mà một số module nổi tiêng lại bỏ qua việc conform theo AMD, ví dụ
tiêu biểu nhất là emberjs. Theo như Tom Dale, một trong những creator của emberjs thì AMD yêu cầu quá nhiều
HTTP request, bởi vì để conform theo AMD thì script phải chia ra thành nhiều module, nhiều file. Ngoài ra
thì AMD cũng yêu cầu toàn bộ module phải wrap trong một function (factory()), việc này có thể ok với một số
người nhưng cũng sẽ gây khó chịu với một số người khác. Và cuối cùng là một số build tool hiện tại (ví dụ như
Grunt https://github.com/cowboy/grunt) hỗ trợ rất tốt cho việc quản lý dependency và version rồi, thế nên
việc conform cấu trúc code của mình theo một cái có sẵn như AMD là không cần thiết.</p>

<h2>IV Kết luận</h2>

<p>Script loader đã và đang trở thành một kĩ thuật không thể thiếu trong việc tạo ra một responsive web app, giúp
rút ngắn thời gian load và render js. Cộng với việc AMD ra đời chúng ta đang thấy ecmascript, cụ thể hơn là
javascript đang có những nỗ lực trở nên mature hơn, để có thể trở thành ngôn ngữ mà developer có thể cảm thấy
thoải mái khi phát triển và khi scope của application bị phình to ra. Tại version ecma hiện tại (ECMA-262) thì
vẫn chưa có một qui chuẩn nào cho việc load script theo module và dependency, tuy nhiên chúng ta có thể hy vọng
về điều này trong một thời gian gần.</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-04-06T00:00:00+09:00" data-updated="true" itemprop="datePublished">Apr 6<span>th</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/programming/'>programming</a>


</div>
		
			<span class="comments"><a href="/blog/2013/04/06/tu-khoa-static-trong-c/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/04/06/tu-khoa-static-trong-c/" itemprop="url">Ý Nghĩa Của Từ Khóa Static Trong C</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>Mở đầu</h2>

<p>Khi học C cơ bản, chắc hẳn bạn sẽ gặp cách dùng từ khoá static như ví dụ dưới đây:</p>

<figure class='code'><figcaption><span>file1.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">num</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;current value of num: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">count</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Kết quả khi chạy chương trình sẽ là:</p>

<figure class='code'><figcaption><span>file2.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>current value of num: 1
</span><span class='line'>current value of num: 4
</span></code></pre></td></tr></table></div></figure>


<p>Biến num khai báo static như trên có 2 đặc điểm:</p>

<ol>
<li>Do được khai báo static nên chỉ được khởi tạo 1 lần duy nhất và tồn tại suốt thời gian chạy của chương trình. Giá trị của biến count sẽ được tích luỹ mỗi khi hàm count được gọi.</li>
<li>Do khai báo trong nội bộ hàm count nên biến chỉ có thể được nhìn thấy bởi các câu lệnh trong hàm count. Nói cách khác, biến nm là 1 biến nội bộ (local variable).</li>
</ol>


<p>Tuy vậy bạn sẽ bất ngờ khi bắt gặp những cách sử dung static trong như ví dụ dưới đây:</p>

<figure class='code'><figcaption><span>main.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">count</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">num</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;current value of num: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;value of a: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>    <span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">count</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ta bắt gặp static ở 2 nơi nữa:</p>

<ol>
<li>static trong khai báo hàm</li>
<li>static trong khai báo biến toàn cục</li>
</ol>


<h2>2 từ khoá static này có ngữ nghĩa như thế nào?</h2>

<p>Để hiểu được ngữ nghĩa mới của static này, ta cần hiểu 1 khái niệm: đơn vị biên dịch (translation unit).</p>

<p>Mỗi project thường được viết trên nhiều file (vì mục đích phân chia module, đảm bảo tính dễ bảo trì). Mỗi file.c trong dự án sẽ là 1 đơn vị biên dịch. Quá trình biên dịch 1 project C sẽ là: biên dịch các đơn vị độc lập <em>.c ra các object file </em>.o (*.obj) và liên kết (link) các đơn vị object file thành chương trình.</p>

<p>Mỗi đơn vị sẽ có các thủ tục (procedure) hoặc function riêng. Code ở 1 đơn vị biên dịch có thể sử dụng thủ tục hoặc hàm, hay cả biến toàn cục ở đơn vị biên dịch khác. Ví dụ:</p>

<figure class='code'><figcaption><span>main.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//-----------------------</span>
</span><span class='line'><span class="c1">//A.c</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">avar</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// -----------------------</span>
</span><span class='line'><span class="c1">//C.c</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">avar</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">d</span><span class="p">()</span> <span class="p">{};</span>
</span></code></pre></td></tr></table></div></figure>


<p>thì trong a() của A.c ta có thể gọi c() một cách thoải mái. Biến avar sẽ được sử dụng cả ở A.c và C.c (biến toàn cục thực thụ!)</p>

<p>Để hạn chế việc sử dụng này (tránh va đụng tên hàm giữa các đơn vị biên dịch), người ta đưa khái niệm hàm tĩnh (static function) và biến tĩnh (static global variable).</p>

<p>Ngữ nghĩa:</p>

<ul>
<li>Biến toàn cục tĩnh sẽ có phạm vi trên đơn vị biên dịch. Điều đó có nghĩa là đơn vị khác không có cách nào truy cập được biến này.</li>
<li>Hàm tĩnh sẽ có phạm vi trên đơn vị biên dịch. Điều đó có nghĩa đơn vị khác không thể truy cập được hàm này.</li>
</ul>


<p>Do đó</p>

<figure class='code'><figcaption><span>main.c </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">//-----------------</span>
</span><span class='line'><span class="c1">//A.c</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">avar</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//------------------</span>
</span><span class='line'><span class="c1">//C.c</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">avar</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">d</span><span class="p">()</span> <span class="p">{};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nếu ta khai báo static như trên, các hàm c, d trong C.c sẽ không thể nào truy cập được hàm a cũng như biến avar (dù rằng avar được khai báo extern trong C.c).</p>

<h2>Tóm lược</h2>

<p>static có 2 ngữ nghĩa:</p>

<ul>
<li>Khi được sử dụng trong phạm vi toàn cục của 1 đơn vị biên dịch, static hạn chế truy cập từ các đơn vị biên dịch khác (áp dụng với cả hàm và biến toàn cục).</li>
<li>Khi được sự dụng trong phạm vi cục bộ của 1 thủ tục hay hàm, static có nghĩa là biến được khai báo tồn tại trong suốt thời gian chạy của chương trình và chỉ được khởi tạo 1 lần duy nhất.</li>
</ul>


		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2013-04-01T00:39:00+09:00" data-updated="true" itemprop="datePublished">Apr 1<span>st</span>, 2013</time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/unix/'>unix</a>


</div>
		
			<span class="comments"><a href="/blog/2013/04/01/gioi-thieu-ve-unix-process/#disqus_thread">Comments</a></span>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2013/04/01/gioi-thieu-ve-unix-process/" itemprop="url">Giới Thiệu về Unix Process</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Là một kỹ sư lập trình hệ thống, một server guy, hay là một sys admin, sys dev,
sys ops,&#8230; phần lớn thời gian bạn sẽ phải làm việc trên hệ thống Unix.
Để làm việc trên Unix, chúng ta tương tác với hệ điều hành thông qua các
lệnh (command). Mỗi lệnh trên Unix khi thực thi sẽ run một process hoặc một
group các processes.</p>

<p>Trong bài viết này mình giới thiệu các kiến thức và kỹ thuật cơ bản để làm việc
với Process trên Unix. Bài viết sẽ trình bày với code minh hoạ bằng Ruby (rồi
bạn sẽ thấy Ruby rất đơn giản). Tất cả các code mình hoạ được chạy trên
môi trường Unix (Linux của chính là Unix - nếu bạn chưa biết, vì thế đừng ngần
ngại thử nó trên máy bạn).</p>

<p>Dù mình đã rất cố gắng, nhưng có thể vẫn có sai sót, mình rất cám ơn các ý kiến
đóng góp</p>

<h2>I. Một số kiến thức tổng quan</h2>

<p>Tất cả các chương trình trong Unix thực chất đều là các processes. terminal bạn
chạy, apache, nginx, vim, hay bất cứ lệnh nào bạn gõ vào terminal. Process chính
là đơn vị cấu thành nên Unix. Nó chính là một instance của chương trình bạn viết
ra. Nói cách khác mỗi dòng code của bạn, sẽ được thực thi trên một process.</p>

<p>Unix cung cấp tool <code>ps</code> để list ra tất cả các process đang chạy trên hệ thống</p>

<figure class='code'><figcaption><span>proc.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$&gt;</span> ps -e -opid,ppid,user,rss,command
</span><span class='line'>PID   PPID  USER     RSS      COMMAND
</span><span class='line'>1     0     root     152      init <span class="o">[</span>2<span class="o">]</span>
</span><span class='line'>1695  1     root     428      /usr/sbin/sshd
</span><span class='line'>1863  1     root     48       /sbin/getty 38400 tty1
</span><span class='line'>1864  1     root     48       /sbin/getty 38400 tty2
</span><span class='line'>1865  1     root     48       /sbin/getty 38400 tty3
</span><span class='line'>1866  1     root     48       /sbin/getty 38400 tty4
</span><span class='line'>1867  1     root     48       /sbin/getty 38400 tty5
</span><span class='line'>1868  1     root     48       /sbin/getty 38400 tty6
</span><span class='line'>24477 1695  root     2888     sshd: vagrant <span class="o">[</span>priv<span class="o">]</span>
</span><span class='line'>24479 24477 vagrant  1996     sshd: vagrant@pts/0
</span><span class='line'>24480 24479 vagrant  2328     -bash
</span><span class='line'>24591 24480 vagrant  1060     ps -e -opid,ppid,user,rss,command
</span></code></pre></td></tr></table></div></figure>


<p>Ở đây, mình chạy lênh <code>ps</code> và show ra các thuộc tính <code>pid,ppid,user,rss,command</code>
của process (chú ý (1) <code>ps</code> có rất nhiều option để chạy, nếu bạn muốn hiểu chỉ
tiết, hãy sử dụng <code>man ps</code> để biết, (2) kểt quả trả về chỉ là một phần các
process trên máy mình). Các thông tin mình muốn hiện thị ở đây bao gồm:</p>

<ol>
<li>PID - Process ID (id của process),</li>
<li>PPID - Parent Process ID (id process cha của process đó),</li>
<li>USER (tên user trên Unix start process),</li>
<li>RSS (Resident Set Size) có thể coi bộ nhớ mà process sử dụng,</li>
<li>COMMAND - command mà user sử dụng để chạy processs</li>
</ol>


<p>Chú ý rằng dòng cuối trong kết quả trả về show ra COMMAND là
<code>ps -e -opid,ppid,user,rss,command</code> - chính là lệnh mà chúng ta dùng để chạy.
Điều đó chứng tỏ, mỗi một command chính là một process !?</p>

<p>Ngoài ra lệnh ps cũng cho chúng ta thấy, mỗi một Process sẽ có một Process ID,
và thuộc về một Process cha nào đó. Process ID là duy nhất đối với mỗi một
process, tức là 2 process khác nhau chắc chắn phải có PID khác nhau. Ngoài ra
Process ID là không thể thay đổi trong khi chạy process.</p>

<h3>1. Làm sao hệ điều hành đánh số các Process ID?</h3>

<p>Process ID được đánh số theo thứ tự tăng dần. Bắt đầu từ 0 và tăng lên cho tới
khi gặp giá trị maximum. Giá trị maximum của Process ID là có thể cấu hình được
tuỳ vào từng hệ thống.</p>

<p>Trên Linux bạn có thể xem và thay đổi giá trị mặc định của Process ID maximum
bằng cách thay đổi file <code>/proc/sys/kernel/pid_max</code></p>

<figure class='code'><figcaption><span>main.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># read current maximum value of process id</span>
</span><span class='line'><span class="nv">$&gt;</span> cat /proc/sys/kernel/pid_max
</span><span class='line'>32768
</span><span class='line'>
</span><span class='line'><span class="c"># set maximum value for process id</span>
</span><span class='line'><span class="nv">$&gt;</span> <span class="nb">echo </span>40000 &gt; /proc/sys/kernel/pid_max
</span></code></pre></td></tr></table></div></figure>


<p>Khi process ID tăng đến giá trị maximum value, hệ điều hành (OS) sẽ quay trở lại
đánh số từ một giá trị cụ thế (một số tài liệu nói giá trị này với Linux là 300,
và với Mac OS là 100 - mình chưa biết cách để kiểm nghiệm điều này một cách an
toàn)</p>

<p>UNIX cung cấp syscall <code>getpid</code> trả về Process ID của process hiện tại. Bạn có thể
viết một chương trình C đơn gian để lấy ra process id với <code>getpid</code>. Tuy nhiên,
bài viết này của tôi sẽ tập trung vào ngôn ngữ Ruby</p>

<p>Trong Ruby, muốn lấy Process ID của process hiện tai, bạn sử dụng <code>Process.pid</code>.</p>

<figure class='code'><figcaption><span>pid.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;Process pid: </span><span class="si">#{</span><span class="no">Process</span><span class="o">.</span><span class="n">pid</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Dòng code trên gọi tới hàm <code>puts</code> - hàm này có tác dụng in một String ra màn hình.
Chúng ta có thể manipulate các String trong Ruby thông qua các syntax #{}. Code
ruby trong #{ } sẽ được thực hiện trước khi truyền cho String</p>

<figure class='code'><figcaption><span>irb.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="vg">$&gt;</span> <span class="n">irb</span>
</span><span class='line'>
</span><span class='line'><span class="n">irb</span><span class="p">(</span><span class="n">main</span><span class="p">):</span><span class="mo">001</span><span class="p">:</span><span class="mi">0</span><span class="o">&gt;</span> <span class="nb">puts</span> <span class="s2">&quot;Example for String manipulate: 1 + 2 = </span><span class="si">#{</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="no">Example</span> <span class="k">for</span> <span class="nb">String</span> <span class="ss">manipulate</span><span class="p">:</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'><span class="o">=&gt;</span> <span class="kp">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Các file Ruby có extension là .rb. Để chạy một file ruby, bạn dùng lệnh
 <code>ruby &lt;file_name&gt;</code>. Không cần phải compile, rất đơn giản phải không)</p>

<h3>2. Liệu có phải process nào cũng có Process cha?</h3>

<p>Ở  trên tôi đã nói rằng, mỗi một process đều thuộc về một Process cha nào đó.
Nếu bạn suy nghĩ kỹ, bạn sẽ thấy có điều gì đó không ổn? À, thực ra điều này
liên quan đến quá trình khởi động của UNIX. Khi UNIX được khởi động, nó sẽ start
một process số 0 (với PID = 0) (process này là process của Kernel UNIX). Process
0 sẽ tạo ra cho nó một Process con, Process 1. Trong phần lớn hệ thống, Process 1
được đặt tên là init process, các process khác được tạo ra đều từ init process.</p>

<p>Hãy quay lại ví dụ về lệnh <code>ps</code> như ở phần đầu mục I. Bạn có thể để ý thấy PPID
của dòng đầu tiên là 0. Đó chính là process đầu tiên của OS.</p>

<p>Vậy là process trong Unix thực chất được tổ chức dưới dạng cây. Mỗi một node
trong cây đại diện cho một process trong Unix. Gốc chính là process 0, các con
của một node chính là các process con của process ứng với node đó.</p>

<p>Trong Ruby, để lấy ra parent process id của một process, chúng ta sử dung <code>Process.ppid</code></p>

<figure class='code'><figcaption><span>ppid.rb </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="c1"># file test_ppid.rb</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;Process id </span><span class="si">#{</span><span class="no">Process</span><span class="o">.</span><span class="n">pid</span><span class="si">}</span><span class="s2">, parent process id </span><span class="si">#{</span><span class="no">Process</span><span class="o">.</span><span class="n">ppid</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Cũng rõ ràng đấy chứ. Liệu tôi có quên gì nữa không nhỉ?</p>

<p>Vấn đề là làm sao một process  có thể sinh ra một process con? À đừng lo, tôi
sẽ nói kỹ về điều này ở phần 2</p>

<h3>3. Process Resource</h3>

<p>Ngoài ra lệnh <code>ps</code> của chúng ta còn cho thấy, mỗi Process đều có RSS khác nhau.
RSS chính là bộ nhớ mà Process sử dụng. Các process khác nhau, có bộ nhớ khác nhau.
Nói cách khác, không gian địa chỉ của các Process là riêng biệt. Nhớ thiết kế này
mà các Process là độc lập với nhau. Nếu một Process bị chết, thì nó cũng không
ảnh hưởng gì tới các Process khác.</p>

<p>Ngoài bộ nhớ, hệ điều hành còn cấp phát cho Process các tài nguyên khác đó là các
file descriptor. Nhớ rằng trên UNIX, mọi thứ đều là file. Điều đó có nghĩa là,
devide được coi như file, socket được coi như file, pipe cũng là file, và file
cũng là file!!! Để cho đơn giản, chúng ta sẽ dùng Resource thay cho khái niệm
file nói chung, và file đại diện cho khái niệm file thông thường.</p>

<p>Bất cứ khi nào bạn mở một Resource trong một process, resource đó sẽ được gán với
một số file descriptor. File descriptor là không được chia sẽ giữa các process
không liên quan. Các resource sẽ sống và tồn tại cùng  với process mà nó thuộc về.
Khi process chết đi, các resource gắn với nó sẽ được close và exit.</p>

<p>Mỗi một process sẽ có 3 files descriptor mặc định, bạn hẳn rất quen thuộc với
chúng, đó chính là stdin, stdout và stderr. Các file descriptor được đánh số tăng
dần từ 0 đến giá trị lớn nhất. Mỗi một process sẽ có một số giới hạn các file
descriptor nó được quyền sử dụng.</p>

<h2>II. forking</h2>

<p>Ở phần I.2, chúng ta đã nói về  process cha và process con, và đưa ra câu hỏi,
làm sao một process có thể sinh ra các process khác.</p>

<p>UNIX cung cấp một công cụ tuyệt vời để làm điều đó.
Bạn chắc đã đoán ra, đó chính là <code>fork</code>.
Theo cá nhân tôi, <code>fork</code> có lẽ là một trong những chức năng tốt nhất của UNIX.
Vì sao ư? Vì process con được tạo ra với fork có 2 đặc điểm:</p>

<ul>
<li>process con được copy tất cả các memory từ process cha.</li>
<li>process con sẽ được kế thứa từ process cha các resource</li>
</ul>


<p>Điều này có nghĩa là nếu trong process cha, bạn đã định nghĩa biến a, và gán
giá trị cho nó, process con cũng có thể sử dụng biến đó.</p>

<p>Uhm&#8230; Không phải như thế sẽ dẫn đến tình trạng 2 process cùng thay đổi một biến
hay sao, vả lại chẳng phải các process là độc lập về bộ nhớ.</p>

<p>À, tức là thế này, khi fork một process mới, bộ nhớ của process con và process
cha vẫn là độc lập, nhưng hệ điều hành sẽ sử dụng cơ chế copy-on-wright (COW) để
thực hiện việc đó. Tức là nếu process con không thay đổi các giá trị trong
process cha, process con và process cha sẽ vẫn dùng chung bộ nhớ. Điều này làm
cho các process con chỉ đọc, sẽ có memory rất nhỏ. Hay nói cách khác, UNIX cung
cấp cho chúng ta một công cụ để chạy các multiprogram với một lượng resource vửa đủ.</p>

<p>Điều này đặc biết tốt khi bạn cần load các library. Process cha sẽ đảm nhiệm việc
load các library khác nhau. Sau khi load xong, nó fork ra các process con, và thực
hiện việc điều khiển các process con. Các process con nhờ cơ chế COW, không cần
phải tốn thời gian load library nữa mà vẫn có thể truy xuất vào các library</p>

<p>Ngoài ra các process cha chia sẻ với process con các resource cũng dẫn đến một
kỹ thuật khá thú vị: pre-forking - đặc biệt hiệu quả trong việc lập trình server.</p>

<p>Kỹ thuật này được mô tả như sau:</p>

<ul>
<li>Main process khởi tạo một listening socket</li>
<li>Main process fork ra một list các children process. Chú ý các children process
này cũng sẽ listen trên socket mà main process tạo ra. Nhưng việc dispatch các
incomming connection tới các children process là được thực hiện trên kernel.
Điều này làm cho việc dispatch các incomming connection là rất nhanh</li>
<li>Mỗi process sẽ accept các connection từ shared socket và xử lý chúng riêng biệt</li>
<li>Main process sẽ kiểm soát các children process. (cung cấp lệnh để tắt tất cả
các children process, tạo một child process mới khi một child process bị crash&#8230;)</li>
</ul>


<p>Kỹ thuật pre-forking được sử dụng rất nhiều. ví dụ: apache (httpd), nginx,</p>

<pre><code>celery, postgresql, rabbitmq, ....
</code></pre>

<p>Process trong Unix là một lĩnh vực rất thú vị, đặc biệt là trong lập trình hệ
thống và lập trình server. Bài viết chỉ mới đề cập đến một vài kiến thức và kỹ
thuật ban đầu với Process. Còn rất nhiều vấn đề chưa đề cập, như</p>

<ul>
<li>Tương tác giữa các process (IPC)</li>
<li>Điều khiển các process</li>
<li>Orphaned, daemon, zoombie, process &#8230;</li>
</ul>


<p>Hy vọng trong tương lai, mình sẽ có thể viết về các vấn đề này kỹ hơn.</p>

<h2>Update</h2>

<p>Bản slide tôi trình bày tại công ty Framgia về UNIX Process</p>

<script async class="speakerdeck-embed" data-id="ce0d6da05a2e0130b5ab22000a8f8802" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>


<p>Bài viết được lấy từ blog <a href="http://kiennt.com/blog/2013/01/20/introduction-to-unix-process.html">http://kiennt.com</a></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
        <a href="/blog/page/5/" class="prev">Prev</a>
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2013

    kỹ thuật máy tính


</footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'ktmt';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





		</div>
	</div>
</body>
</html>
